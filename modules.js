/**
 * 我们为什么要用modules?
 *
 * 因为我们写的js变多了，
 * 我们为什么写的js多了呢，因为我们的项目越来越复杂，越来越大
 * 如果整个项目总共五个页面，1000行js，那在开发过程中也不会遇到什么难的问题，即使遇到一两个问题，也基本可以用人堆上去去解决掉，更是几乎不需要考虑什么工程的问题
 * 但是，当我们项目复杂度上去了之后，
 * 我们写的js多了的话，就会面临这么几个绕不开的问题
 *
 * 我们看一下 跟进页面
 *
 * 这个页面呢，当初的开发时间是两个礼拜
 * 如果我们只让一个人来写的话，两周是无论怎么都搞不完的
 *
 *  我们就遇到了，第0个问题，这一个页面怎么让多个人并行的开发，而且他们可以合作的良好
 *
 *
 *
 * 那我们肯定是要拆分，我们会很容易按照页面的结构拆分成这么几个部分，每个人各自开发一个或者两个部分
 * 那么这个时候，我们的js就不能都写在一个文件里面了，第一，合并代码时冲突能够冲突死，第二，都写在这里的话，这个单个文件的代码量太大了，可能会达到几千行，后期基本是没法维护的
 * 那么我们最好的想法是，每个部分都有一个单独的html，css，js
 * 那么对应的同事负责哪个部分，就在哪个部分对应的html，css，js文件里面写代码就好了，然后再通过某种手段，让我们这几个分开的部分再合并起来，那就完美了
 *
 * 我们把页面分了分，然后就开始各自干活了
 *
 * 写着写着，有一天发现，哎，我的js里面的submitForm方法怎么执行的效果和昨天不一样了呢，最后查啊查，发现，马丹，原来另一个人的js里面也写了一个同样名字的方法，这个时候我们就遇到了多人协作或者项目复杂时的最普通的一个问题，命名冲突
 * 因为js作用域的话目前只有函数和块级作用域，那么如果我们直接在一个js里面写代码的话，它里面的变量和方法是暴露在全局的，所以这样很容易引起命名冲突
 * 那怎么办呢？
 *
 * 某个人妥协一下呗，把自己的名字改一下，如果遇上两个人像我这样的，心想，马丹，凭什么我改，我这个函数名多简洁，而且是自解释的，谁看到submitForm都知道是提交表单数据，我就不改，要改你改。
 * 对方妥协了，好这次我改，但是下次再冲突，就你改啊
 * 同学们，看到没，下次再冲突，说明这个解决方案不是最好的啊，说不定什么时候就又冲突了
 * 那么想较好的解决这个问题呢
 *
 * 基本是🈶两个思路
 * 1、你不是暴露在全局么，我不让你暴露在全局不就好了么，我给你最外层套一个自执行的匿名函数，这样你也就暴露在这个函数作用域里面了
 */

(function() {
    //写代码
})();

/*
 * 2、我所有的代码都加个命名空间就好了么（这个也是我们现在在用的思路）
 *
 */
//你的代码
var userInfo = {
    id: '',
    submitForm: function() {}
};

//他的代码
var userFollow = {
    submitForm: function() {}
};

/**
 * 大家又开始欢乐的写代码，过了一段时间，一个同事说，哎，产品提了一个需求，导致好像我这边得调用你的方法了
 * 你赶紧把方法暴露出来啊
 *
 * 这样我们就遇到了，多人协作的第二个问题，一个模块要使用另一个模块的方法或者变量
 */

//自执行匿名函数写法，心想，这个我要暴露对外的方法的话，我只能往全局变量里面放啊，这全局变量一多的话，又指不定啥时候就冲突了呢

//用命名空间的人想，马丹，我就是个对象啊，别说你需要的，你不需要的都给你暴露出来了
//不行，我得改一改，不需要的我得隐藏掉，需要的给你暴露出来
//于是代码就变成了这个样子

var userInfo = (function() {
    var id = '';
    var submitForm = function() {};

    return {
        submitForm: submitForm
    };
})();

//这样，另一个人就可以调用了，通过
userInfo.submitForm();
//这个命名空间有个问题是，当你的命名空间越来越长的话，记忆起来费力


//然后大家又开始自己写自己的代码了，某一天，大家发现，哎，我们居然都按照接口文档盲写完了，要不我们联跑一下
//结果联跑时，连页面都打不开了，发现脚本在报错，xxx is not defined
//
//一查发现是，a.js文件调用了b.js文件里面的方法，但是他们在html里面用script标签写的加载顺序却是，先加载a再加载b，那当然找不到方法，要报错了
//这个时候我们就遇到了 多人协作或者项目复杂的第三个问题，我们要手动维护脚本的依赖关系，具体到就是哪个script标签在哪个script标签的前面还是后面
//
//
//过来一会解决了依赖问题后，发现了一个新问题，
//我这边在获取数据时，得需要你那边的数据
//更棘手的是，你那边的数据也是调接口来的
//那我怎么知道你调接口调完了呢
//
//我们就遇到了多人协作的第四个问题，模块之间的数据通信问题
//这个问题单纯的用modules是解决不了的，得结合一些其他的理念啊，我们自己是用了订阅者发布者模式
//
//解决了之后，联测了半天，终于都跑通了，赶紧上预发环境拿真实的数据测试，并且给产品和领导么过一下
//这个时候，产品看完了，整体很满意，就是指出来一个问题啊
//你这个页面怎么加载这么慢呢
//自己查了一下，马丹，我们把页面拆了7个部分，那就是最少7个css和7个js请求呢，这么多请求当然不会快了
//这个时候我们就遇到了，页面复杂了之后引出来的第五个问题：
//http请求变多了，那我们就只能减少请求，改用雪碧图的用雪碧图，该合并压缩的合并压缩，那么这个我们总不能一直手动来处理吧，那么我们就需要引入gulp和webpack这样的工具
//
//


//那么我们带着这些问题，来看一下modules，看它能解决那些问题
//1、有module作用域，在module里面创建的变量不会被添加到全局作用域中
//2、export和import关键字
//我们可以通过export关键字把公共的变量或者方法暴露出去
export var userId = '';
export function submitForm() {}

//import出来的变量类似于 const 关键字声明的，
//不能重复声明，不能再次binding
import {userId, submitForm} from './b.js';
import * as userInfo from './b.js';

//当然也可以重命名
import {submitForm as submitUserInfoForm} from './b.js';





